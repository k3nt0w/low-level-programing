# 【低レベルプログラミング】アセンブリ言語導入【その２】

前回の続きです。

本記事では、前記事で書いたハローワールドを読み解くことを目標とします。
ほとんど、[低レベルプログラミング](http://amzn.asia/d/0wGhnsd)を２章までのまとめに近い内容になってるはずです。
また、付属している設問にも回答していこうと思います。

## 目次

1. 第１章 「コンピュータアーキテクチャの基礎」のまとめ
2. ハローワールドの解説
3. 第２章の問題を解いてみる

## 1. 第１章 「コンピュータアーキテクチャの基礎」のまとめ

前回は、実行環境の構築のみで各専門用語の説明を全くしていませんでした。
解説に入る前に、ちょうど第 1 章の設問が用語のまとめになりそうなので、本記事ではそこから始めようと思います。
また書籍にある、全設問を記載しているわけではないのでご注意ください。

### 第１章の問題と回答

1. フォン・ノイマン・アーキテクチャの主な原則は？

   １章では、フォン・ノイマン・アーキテクチャの主要な機能として以下が述べられている。

   - 0 と 1 で表されるビット(bit)という情報単位のみがメモリに保存される
   - 命令とデータが区別されることなくメモリに保存される
   - メモリはラベルによってインデックスが付与された、複数の cell によって組織化されている
   - 特別な命令をのぞいて、プログラムは逐次的にフェッチされる命令軍で構成されている

2. レジスタとは？

   CPU に直接備わっているメモリセルのこと。
   レジスタにより、CPU とメモリ間のデータ交換時に生じる CPU タイムを削減できる。

3. ハードウェアスタックとは？

   ２つのマシン語命令（push と pop）と１個のレジスタ（rsp）によって実装された、スタックを実現するエミュレーションのこと。

4. 割り込みとは？

   外部イベントを基準としてプログラムの実行順序を変更すること。ゼロによる除算なども割り込みによって特別なルーチンを実行する。

5. フォン・ノイマンのモデルの主な問題点で、現在の拡張が解決しているのは？

   - メモリへの問い合わせが必須だった問題を**レジスタ**によって解決
   - 対話性がなかった問題を**割り込み**によって解決
   - コードを効果的に隔離できなかった問題を**ハードウェアスタック**により解決
   - プログラムがどんな命令でも実行できてしまう問題を**プロテクションリング**によって解決
   - プログラムそのものを互いに隔離できなかった問題を**仮想メモリ**によって解決

6. スタックポインタの目的は？

   ハードウェアスタックのもっとも上にある要素のアドレスを格納すること。

7. スタックは空になるか？

   ならない。push していなくても pop は実行可能であり、何らかの値を返す。

8. スタック内の要素は数えられるか？

   不可能。7. と同じ理由で pop は任意の回数実行できる。そのため要素数を数えることはできない。

以上が、第１章の問題と回答です。
知っている人にとってはかなり当たり前の内容だと思いますが、これで一旦用語が整理できました。
それではこれらの用語を使いつつ、前記事で扱ったハローワールドを紐解いて行きましょう。

## 2. ハローワールドの解説

まずはハローワールドを表示するアセンブリを再掲します。

```avrasm
section .data
message: db 'hello, world!', 10

section .text
global _start

_start:
  mov rax, 1
  mov rdi, 1
  mov rsi, message
  mov rdx, 14
  syscall

  mov rax, 60
  xor rdi, rdi
  syscall
```

それでは、まずそれぞれの記述が何を意味しているのかに注目して、上から順に紐解いてみましょう。

<font color=orange>※ 注意: この書籍で扱っているアセンブリは NASM です。GAS とは異なるので注意してください！</font>

### 2.1. 文法編

### 2.1.1. section

まずは１行目にある`section` から。

前節で説明したように、

> 命令とデータが区別されることなくメモリに保存される

というのがフォン・ノイマン型の主要な機能としてあげられます。
そのため、プログラマが命令とデータを簡易的に区別できるように用いられるのが**セクション**です。

１行目には

```
section .data
```

と記述されていますが、`section .data`はグローバル変数を記述するためのセクションであることを意味します。
一方、４行目にある`section .text`は命令を記述するセクションを意味します。

セクションは機械語にコンパイルされず、コンパイル時の補助的な役割を担います。
このように直接機械語に変換されず、変換処理を制御する要素を**ディレクティブ**と呼びます。

### 2.1.2. label

次に２行目

```
message: db 'hello, world!', 10
```

で使われている `message:` について。これは**ラベル**と呼ばれます。
ラベルを用いることで、プログラマがわかりやすい名前をアドレス値に付与することができます。

高級言語の変数に似ている概念ですが、アセンブリでは変数や手続きが厳密に区別されないため、**ラベル**という言葉を用いるのが一般的だそうです。

参考: [NASM Manual: Layout of a NASM Source Line](https://www.nasm.us/doc/nasmdoc3.html#section-3.1)

### 2.1.3. db

同じく二行目の`db`について。これも、section と同様にディレクティブの一種です。
db ディレクティブはバイトデータを初期化するために用いられます。

つまり、以下のように記述することで、文字列`hello, world!`に対応する ASCII コードと、改行を示す特殊コードの`10`が、`messsage`ラベルに格納されます。

```
message: db 'hello, world!', 10
```

db の他にもワードデータを初期化するための`dw`やダブルワードを初期化するための`dd`などが存在します。
詳しくは以下を参照してください。

参考: [NASM Manual: DB and Friends: Declaring Initialized Data](https://www.nasm.us/doc/nasmdoc3.html#section-3.2)

### 2.1.4. global

次に、5 行目

```
global _start
```

にある`global`です。
`global`も`section`や`db`と同じくディレクティブであり、プログラムの実行を開始するアドレスを指定します。
`_start`はラベルであり、８行目以下の命令群が格納されています。

つまりこのプログラムは`_start`の先頭に記述されている`mov rax, 1`から実行されることを意味します。

## 2.2. 命令編

ここまでの解説で、とりあえず各コマンドの意味は掴めてきたと思います。

次に、プログラムの主役である、命令部分を詳しく見て行きましょう。

命令部分のみを再掲します。

```avrasm
mov rax, 1
mov rdi, 1
mov rsi, message
mov rdx, 14
syscall

mov rax, 60
xor rdi, rdi
syscall
```

文法編と同様に一つずつ紐解いて行きます。

### 2.2.1. syscall

syscall とは、
